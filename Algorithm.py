# -*- coding: utf-8 -*-import numpy as npimport functionsleft = [0,-100,-10,-100,-100,-30,-100,-1.28,-500,-5.12,-32,-600,-50,-50]right = [0,100,10,100,100,30,100,1.25,500,5.12,32,600,50,50]l = left[8]r = right[8]# particleclass Particle:    def __init__(self):        self.pos = [0, 0]  # present position        self.speed = [0, 0]        self.pbest = [0, 0]  # best position ever# PSOclass PSO:    def __init__(self):        self.w = 0.5  # 惯性因子        self.c1 = 1 # 自我认知学习因子        self.c2 = 1 # 社会认知学习因子        self.gbest = [0, 0] # 种群当前最好位置        self.N = 20 # 种群中粒子数量        self.POP = [] # 种群        self.iter_N = 100 # 迭代次数    # 适应度计算函数    def fitness(self, x, y):        return functions.fitness8(x, y)    # 找到全局最优解    def g_best(self, pop):        for bird in pop:            if bird.fitness < self.fitness(self.gbest[0],self.gbest[1]):                functions.equals(self.gbest,bird.pos)    # 初始化种群    def initPopulation(self, pop, N):        for i in range(N):            bird = Particle()            bird.pos[0] = np.random.uniform(l,r)            bird.pos[1] = np.random.uniform(l,r)            bird.fitness = self.fitness(bird.pos[0],bird.pos[1])            functions.equals(bird.pbest,bird.pos)            pop.append(bird)        # 找到种群中的最优位置        self.g_best(pop)    # 更新速度和位置    def update(self, pop):        for bird in pop:            # 速度更新            speed = [0, 0]            speed[0] = self.w * bird.speed[0] + self.c1 * np.random.random() * (bird.pbest[0] - bird.pos[0]) + self.c2 * np.random.random() * (self.gbest[0] - bird.pos[0])            speed[1] = self.w * bird.speed[1] + self.c1 * np.random.random() * (bird.pbest[1] - bird.pos[1]) + self.c2 * np.random.random() * (self.gbest[1] - bird.pos[1])            # 位置更新            pos = [0, 0]            pos[0] = bird.pos[0] + speed[0]            pos[1] = bird.pos[1] + speed[1]            if l<pos[0]<r and l<pos[1]<r: # 粒子在搜索空间内                functions.equals(bird.pos,pos)                functions.equals(bird.speed,speed)                # 更新适应度                bird.fitness = self.fitness(bird.pos[0],bird.pos[1])                # 更新本粒子历史最好位置                if bird.fitness < self.fitness(bird.pbest[0],bird.pbest[1]):                    functions.equals(bird.pbest,bird.pos)    # 最终执行    def execute(self):        self.initPopulation(self.POP, self.N)        for i in range(self.iter_N):            self.update(self.POP)            self.g_best(self.POP)pso = PSO()pso.execute()# for ind in pso.POP:#     print("positon:", ind.pos, "fitness:", ind.fitness)print("positon:", pso.gbest, "fitness:", pso.fitness(pso.gbest[0],pso.gbest[1]))